local paramsutil = require "paramsutil"
local func = require "track_design_patterns/func"
local coor = require "track_design_patterns/coor"
local line = require "track_design_patterns/coorline"
local arc = require "track_design_patterns/coorarc"
local trackEdge = require "track_design_patterns/trackedge"
local streetEdge = require "track_design_patterns/streetedge"
local station = require "track_design_patterns/stationlib"
local pipe = require "track_design_patterns/pipe"
local tdp = require "track_design_patterns"

local abs = math.abs
local pi = math.pi
local atan = math.atan
local cos = math.cos
local sin = math.sin
local ceil = math.ceil

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {tdp.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}
local wallList = {
    "track_design_patterns/concrete_wall",
    "track_design_patterns/brick_wall",
    "track_design_patterns/arch_wall",
    "track_design_patterns/track_multi_sound_insulation_10m"
}
local colList = {
    "track_design_patterns/concrete_col",
    "track_design_patterns/brick_wall",
    "track_design_patterns/arch_wall",
    "track_design_patterns/track_multi_sound_insulation_10m"
}
local wallLengthList = {5, 5, 5, 10}
local colLengthList = {10, 5, 5, 10}
local wallHeightList = {15, 15, 15, 8}
local wallWidthList = {1, 1, 1, 0.4}
local wallTransList = {
    function(h) return coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.transZ((h > 8 and 8 or abs(h)) - 5.1) end
}


local streetConfig = {
    country = {
        type = {
            "country_old_small.lua",
            "country_old_medium.lua",
            "country_old_large_upgrade.lua",
            "country_old_large.lua"
        },
        width = {
            12, 18, 18, 18
        },
    },
    street = {
        type = {
            "old_small.lua",
            "old_medium.lua",
            "old_large_upgrade.lua",
            "old_large.lua"
        },
        width = {
            12, 18, 18, 18
        }
    }
}

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return tdp.trackType + {
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = func.seqMap({1, 10}, tostring),
            defaultIndex = 1
        },
        {
            key = "sign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radius",
            name = _("Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        
        {
            key = "streetSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "streetRadius",
            name = _("Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "streetUsage",
            name = sp,
            values = {_("Street"), _("Route")},
            defaultIndex = 1
        },
        {
            key = "streetType",
            name = _("Road Type"),
            values = {"S", "M", "L", "XL"},
            defaultIndex = 2
        },
        paramsutil.makeTramTrackParam1(),
        paramsutil.makeTramTrackParam2(),
        {
            key = "slopeSignA",
            name = sp .. "\n" .. _("Slope"),
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slopeA",
            name = _("Begin") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "slopeSignB",
            name = "",
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slopeB",
            name = _("End") .. "(‰)",
            values = pipe.new + {_("Sync")} + func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "lengthM",
            name = sp .. "\n" .. _("Length") .. " \n\n×1000m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        },
        {
            key = "lengthC",
            name = "×100m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 1
        },
        {
            key = "lengthD",
            name = "×10m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        },
        {
            key = "signalSpacing",
            name = sp .. "\n" .. _("Signal Spacing"),
            values = {_("None"), _("Moving Block"), "100", "200", "400", "600", "800", "1000", "1500"},
            defaultIndex = 4
        
        },
        {
            key = "signalPattern",
            name = _("Signal Pattern"),
            values = {"↓↑↓↑", "↑↓↑↓", "↓↓↑↑", "↑↑↓↓", "↓↓↓↓", "↑↑↑↑", _("↕↕↕↕")},
            defaultIndex = 0,
        },
        {
            key = "wallHeight",
            name = sp .. "\n" .. _("Tunnel Height") .. "(m)",
            values = pipe.new * {"↓", _("None")} + func.seqMap({1, 15}, tostring),
            defaultIndex = 1
        },
        {
            key = "openSide",
            name = _("Exposed Side"),
            values = {"A", "B"},
            defaultIndex = 0,
        },
        {
            key = "wallType",
            name = _("Type"),
            values = {_("Concrete"), _("Stone brick"), _("Arch"), _("Noise barrier")},
            defaultIndex = 0
        },
        {
            key = "height",
            name = _("Altitude Adjustment") .. "(m)",
            values = func.seqMap({-10, 15}, tostring),
            defaultIndex = 10
        }
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    func.forEach(params(), function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end

local function guideline(radius, length, signalSpacing, slopeA, slopeB, e)
    local initRad = radius > 0 and pi or 0
    local dRad = math.abs(length / radius) < 2 * pi and -length / radius or 2 * pi * 0.99
    
    local fz =
    (slopeA == slopeB) and
        pipe.exec * function()
            local ln = line.byPtPt(coor.xy(initRad, 0), coor.xy(initRad + dRad, slopeA * length))
            return function(rad) return {z = e + (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y, s = slopeA} end
        end
        or
        pipe.exec * function()
            local radRef = (slopeA > slopeB and 1 or -1) * 0.5 * pi
            local radA, radB = atan(slopeA), atan(slopeB)
            local r = length / (sin(radB) - sin(radA))
            local arch = arc.byOR(coor.xy(0, cos(radA) * r), r)
            return function(rad)
                local pt =
                    func.min(arch / line.byVecPt(coor.xy(0, 1), coor.xy((rad - initRad) * length / dRad + r * sin(radA), 0))
                        , function(a, b) return a:length() < b:length() end)
                return {z = e + pt.y, s = math.tan(arch:rad(pt) - radRef)}
            end
        end
    
    local function signalGrouping(result, leftLength)
        return leftLength <= 0 and result / 1 or signalGrouping(result / ((length - leftLength) / length), leftLength - signalSpacing)
    end
    
    local limits = signalGrouping(pipe.new, length)
        * function(r) return func.map2(
            func.range(r, 1, #r - 1),
            func.range(r, 2, #r),
            function(f, t) return
                {
                    inf = initRad + f * dRad,
                    mid = initRad + (f + t) * 0.5 * dRad,
                    sup = initRad + t * dRad
                }
            end)
        end
    
    local guideline = arc.byOR(coor.xyz(radius, 0, 0), abs(radius)):withLimits({
        inf = initRad,
        mid = initRad + 0.5 * dRad,
        sup = initRad + dRad,
        offset = 0
    })
    
    local zsList = limits
    * pipe.map(function(l)
        return {
            {coor.transZ(fz(l.inf).z), coor.transZ(fz(l.mid).z), coor.transZ(fz(l.inf).s), coor.transZ(fz(l.mid).s)},
            {coor.transZ(fz(l.mid).z), coor.transZ(fz(l.sup).z), coor.transZ(fz(l.mid).s), coor.transZ(fz(l.sup).s)}
        }
    end)

    return guideline, zsList, fz, limits
end

local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = tdp.trackList[params.trackType + 1]
        local catenary = params.catenary == 1

        local streetGroup = streetConfig[params.streetUsage == 0 and "street" or "country"]
        local streetType = streetGroup.type[params.streetType + 1]
        local streetWidth = streetGroup.width[params.streetType + 1]

        local tramType = ({"NO", "YES", "ELECTRIC"})[params.tramTrack + 1]

        local trackBuilder = trackEdge.builder(catenary, trackType)
        local streetBuilder = streetEdge.builder(tramType, streetType)
        
        local nbTracks = params.nbTracks + 1
        local radius = (rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        local radiusSt = (rList[params.streetRadius + 1] * 1000) * (params.streetSign == 0 and 1 or -1)
        local length = params.lengthD * 10 + params.lengthC * 100 + params.lengthM * 1000
        length = length > 0 and length or 1
        
        local signalSpacing = ({length, 20, 100, 200, 400, 600, 800, 1000, 1500})[params.signalSpacing + 1]
        
        local slopeA = slopeList[params.slopeA + 1] * (params.slopeSignA == 0 and 1 or -1) * 0.001
        local slopeB = params.slopeB == 0 and slopeA or slopeList[params.slopeB] * (params.slopeSignB == 0 and 1 or -1) * 0.001
        
        local offsets = tdp.buildCoors(nbTracks, nbTracks)

        local wallHeight = func.seq(-1, 15)[params.wallHeight + 1]
        
        
        
        local guidelineTr, zsListTr, fzTr, limitsTr = guideline(radius, length, signalSpacing, slopeA, slopeB, 0)
        local guidelineSt, zsListSt, fzSt, limitsSt = guideline(radiusSt, length, signalSpacing, slopeA, slopeB, wallHeight)

        local guidelines = offsets.tracks
            * (radius < 0 and pipe.noop() or pipe.rev())
            * pipe.map(function(o)
                local g = (guidelineTr + o)
                return limitsTr
                    * pipe.map(function(l) return func.with(g:withLimits(l), {offset = o}) end)
            end)
        
        local arcs = guidelines
            * pipe.map(pipe.map(tdp.generateArc))
            * pipe.map(pipe.map(pipe.range(1, 2)))
            * pipe.map(pipe.map2(zsListTr, function(a, zs) return func.map2(a, zs, function(ar, nz) return func.map2(ar, nz, coor.apply) end) end))
            * pipe.map(function(segs) return pipe.new * segs
                * pipe.mapi(function(e, i) return {
                    edge = pipe.new * e,
                    snap = pipe.new / {i == 1, false} / {false, i == #segs}
                } end)
            end)
            * pipe.map(station.joinEdges)
            * pipe.map(station.mergeEdges)

        
            
        local street = limitsSt
        * pipe.map(function(l) return guidelineSt:withLimits(l) + 
            (params.openSide == 0 
            and ((offsets.walls[1] + streetWidth * 0.5) * (radiusSt > 0 and -1 or 1)) or ((offsets.walls[2] - streetWidth * 0.5) * (radiusSt > 0 and -1 or 1))) end)
        * pipe.map(tdp.generateArc)
        * pipe.map(pipe.range(1, 2))
        * pipe.map2(zsListSt, function(a, zs) return func.map2(a, zs, function(ar, nz) return func.map2(ar, nz, coor.apply) end) end)
        * (function(segs) return pipe.new * segs
            * pipe.mapi(function(e, i) return {
                edge = pipe.new * e,
                snap = pipe.new / {i == 1, false} / {false, i == #segs}
            } end)
        end)
        * station.joinEdges
        * station.mergeEdges
        
        
        local signalOffset = 5 / (signalSpacing < 20 and 20 or signalSpacing)
        
        local leftSignal = function(i) return i % 2 == 0 and {{true, signalOffset}} or {} end
        local rightSignal = function(i) return i % 2 == 1 and {{false, 1 - signalOffset}} or {} end
        
        local signalPattern = ({
            function(n, i) return n % 2 == 1 and leftSignal(i) or rightSignal(i) end,
            function(n, i) return n % 2 ~= 1 and leftSignal(i) or rightSignal(i) end,
            function(n, i) return n <= nbTracks * 0.5 and leftSignal(i) or rightSignal(i) end,
            function(n, i) return n > nbTracks * 0.5 and leftSignal(i) or rightSignal(i) end,
            function(_, i) return leftSignal(i) end,
            function(_, i) return rightSignal(i) end,
            function(_, i) return i == 1 and {{true, signalOffset}} or (i == #limits * 2 and {{false, 1 - signalOffset}} or {}) end
        })[params.signalPattern + 1];

        local retriveWall = function(ls) return ls[params.wallType + 1] end
        
        local wallGuidelines = offsets.walls
            * (radius < 0 and pipe.noop() or pipe.rev())
            * pipe.map(function(o) return guidelineTr + o end)

        local fenceGuidelines = 
        pipe.new * 
            (params.openSide == 0 
            and {
                offsets.walls[1], 
                offsets.walls[1] + streetWidth
            } 
            or {
                offsets.walls[2] - streetWidth, 
                offsets.walls[2]
            })
        * (radiusSt < 0 and pipe.noop() or pipe.rev())
        * pipe.map(function(o) return guidelineSt + (radiusSt > 0 and -o or o) end)
                
        local function mPlace(fz, mZ)
            return function(fitModel, arcL, arcR, rad1, rad2)
                local z1, z2 = fz(rad1).z, fz(rad2).z
                local size = {
                    lb = arcL:pt(rad1):withZ(z1),
                    lt = arcL:pt(rad2):withZ(z2),
                    rb = arcR:pt(rad1):withZ(z1),
                    rt = arcR:pt(rad2):withZ(z2)
                }
                return mZ * fitModel(size)
            end
        end
        
        local makeWallA = tdp.makeFn(wallHeight < 0)(
            retriveWall(params.openSide == 0 and colList or wallList),
            tdp.fitModel,
            mPlace(
                fzTr,
                retriveWall(wallTransList)(wallHeight)
            ),
            retriveWall(wallWidthList),
            retriveWall(params.openSide == 0 and colLengthList or wallLengthList)
        )
        
        local makeWallB = tdp.makeFn(wallHeight > 0)(
            retriveWall(params.openSide == 1 and colList or wallList),
            tdp.fitModel,
            mPlace(
                fzTr,
                retriveWall(wallTransList)(wallHeight)
            ),
            retriveWall(wallWidthList),
            retriveWall(params.openSide == 1 and colLengthList or wallLengthList)
        )

        
        local makeFenceA = tdp.makeFn(wallHeight > 0)(
            "track_design_patterns/concrete_fence",
            tdp.fitModel,
            mPlace(
                fzSt,
                retriveWall(wallTransList)(0)
            ),
            retriveWall(wallWidthList), 
            5
        )
        
        local makeFenceB = tdp.makeFn(wallHeight < 0)(
            "track_design_patterns/concrete_fence",
            tdp.fitModel,
            mPlace(
                fzSt,
                retriveWall(wallTransList)(0)
            ),
            retriveWall(wallWidthList),
            5
        )
        
        local makeRoof = tdp.makeFn(false)(
            "track_design_patterns/roof_closed",
            tdp.fitModel,
            mPlace(fzTr, coor.transZ(wallHeight)),
            5,
            5
        )

        local walls = pipe.new
            / ((params.openSide == 0 and nbTracks > 1 or params.openSide == 1) and {makeWallA(wallGuidelines[1])} or {})
            / ((params.openSide == 1 and nbTracks > 1 or params.openSide == 0) and {makeWallB(wallGuidelines[2])} or {})
            / {params.openSide == 0 and makeFenceA(fenceGuidelines[radiusSt < 0 and 1 or 2]) or makeFenceB(fenceGuidelines[radiusSt > 0 and 1 or 2])}
            * pipe.flatten()
            * pipe.map(pipe.flatten())
            + (pipe.new * guidelines * pipe.map(pipe.map(makeRoof)) * pipe.flatten() * pipe.flatten())
        
        local terrainGuidelines = offsets.walls
            * (radius < 0 and pipe.noop() or pipe.rev())
            * pipe.map(function(o)
                local ref = guidelineTr + o
                local extra = function(w) return ref + (o > 0 and w or -w) end
                return
                    {
                        ref = ref,
                        outer = extra(1),
                        inner = extra(-1)
                    }
            end)
        
        local polyGen = function(wallHeight, refHeight, guidelines, wHeight)
            local f = function(s) return s.g and
                tdp.generatePolyArc({s.g, guidelineTr}, "inf", "sup")(-0.2, 0)
                * pipe.map(pipe.map(s.fz))
                * station.projectPolys(coor.I())
                or {}
            end
            local polyGen = function(l, e, g)
                return wallHeight == 0 and f(e) or (wallHeight > 0 and f(g) or f(l))
            end
            
            return {
                slot = polyGen(
                    {},
                    {},
                    {g = guidelines.outer, fz = function(p) return coor.transZ(fzTr(p.rad).z)(p) end}
                ),
                equal = polyGen(
                    {},
                    refHeight > 0 and {} or {g = guidelines.ref, fz = function(p) return coor.transZ(fzTr(p.rad).z)(p) end},
                    {}
                ),
                less = polyGen(
                    {g = guidelines.outer, fz = function(p) return coor.transZ(fzTr(p.rad).z)(p) end},
                    refHeight > 0 and {g = guidelines.ref, fz = function(p) return coor.transZ(fzTr(p.rad).z)(p) end} or {},
                    {g = guidelines.outer, fz = function(p) return coor.transZ(fzTr(p.rad).z + wallHeight)(p) end}
                ),
                greater = polyGen(
                    {g = guidelines.outer, fz = function(p) return coor.transZ(fzTr(p.rad).z - wHeight)(p) end},
                    refHeight > 0 and {g = guidelines.ref, fz = function(p) return coor.transZ(fzTr(p.rad).z)(p) end} or {},
                    refHeight >= 0 and {g = guidelines.outer, fz = function(p) return coor.transZ(fzTr(p.rad).z)(p) end} or 
                    {g = guidelines.outer, fz = function(p) return coor.transZ(fzTr(p.rad).z - wHeight + wallHeight)(p) end}
            )
            }
        end

        return
            pipe.new
            * {
                edgeLists = pipe.new 
                / (pipe.new * {street} * station.prepareEdges * streetBuilder.nonAligned())
                    / (pipe.new * {arcs} * station.fusionEdges * pipe.map(station.mergeEdges) * station.prepareEdges * trackBuilder.nonAligned())
                ,
                edgeObjects = length <= signalSpacing and {} or pipe.new
                * func.seqMap({0, nbTracks - 1}, function(n) return
                    func.seqMap({0, #limits * 2 - 1}, function(i) return
                        func.map(signalPattern(n + 1, i + 1), function(p)
                            local isLeft, pos = table.unpack(p)
                            return {
                                edge = n * #limits * 2 + i,
                                param = pos,
                                left = isLeft,
                                model = params.signalSpacing == 1 and "railroad/signal_mb.mdl" or "railroad/signal_new_block.mdl"
                            }
                        end)
                    end)
                end)
                * pipe.flatten()
                * pipe.flatten(),
                models = walls * pipe.flatten(),
                terrainAlignmentLists = station.mergePoly(
                    polyGen(wallHeight, wallHeight, terrainGuidelines[1], retriveWall(wallHeightList)),
                    polyGen(wallHeight, wallHeight, terrainGuidelines[2], retriveWall(wallHeightList))
                )({less = 1.5})
            }
            * station.setHeight(func.seq(-10, 15)[params.height + 1])
    end
end


function data()
    return {
        type = "RAIL_DEPOT",
        description = {
            name = _("Parallel tracks"),
            description = _("One or many tracks with fix radious and signaling spacing.")
        },
        availability = {
            yearFrom = 1850
        },
        -- buildMode = "SINGLE",
        -- categories = {"misc"},
        order = 27218,
        -- skipCollision = false,
        -- autoRemovable = false,
        params = params(),
        updateFn = updateFn()
    }

end
