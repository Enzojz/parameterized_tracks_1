local paramsutil = require "paramsutil"
local func = require "flyingjunction/func"
local coor = require "flyingjunction/coor"
local line = require "flyingjunction/coorline"
local arc = require "flyingjunction/coorarc"
local trackEdge = require "flyingjunction/trackedge"
local station = require "flyingjunction/stationlib"
local pipe = require "flyingjunction/pipe"
local junction = require "junction"
local dump = require "datadumper"
local abs = math.abs
local pi = math.pi
local atan = math.atan
local cos = math.cos
local sin = math.sin

local generateArc = function(fz)
    return function(arc)
        local toXyz = function(pt, z) return coor.xyz(pt.x, pt.y, z) end
        
        local sup = toXyz(arc:pt(arc.sup), fz(arc.sup).z)
        local inf = toXyz(arc:pt(arc.inf), fz(arc.inf).z)
        local mid = toXyz(arc:pt(arc.mid), fz(arc.mid).z)
        
        local vecSup = func.with(arc:tangent(arc.sup), {z = fz(arc.sup).s})
        local vecInf = func.with(arc:tangent(arc.inf), {z = fz(arc.inf).s})
        local vecMid = func.with(arc:tangent(arc.mid), {z = fz(arc.mid).s})
        
        return {
            {inf, mid, vecInf, vecMid},
            {mid, sup, vecMid, vecSup}
        }
    end
end

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local wallList = {
    "track_design_patterns/concrete_wall.mdl",
    "track_design_patterns/brick_wall.mdl",
    "track_design_patterns/arch_wall.mdl",
    "asset/track_multi_sound_insulation_10m.mdl"
}
local wallLengthList = {5, 5, 5, 10}
local wallTransList = {
    function(h) return coor.scaleX(2) * coor.transX(-0.5) * coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.scaleX(2) * coor.transX(-0.5) * coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.scaleX(2) * coor.transX(-0.5) * coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.transY(3.2) * coor.rotZ(pi * 0.5) * coor.transZ((h > 8 and 8 or abs(h)) - 5.1) end
}

local sizeSwitch = {4.03, 5, 6, 7, 9, 12, 18, 24, 30, 36, 42, 50, 65}

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6")},
            defaultIndex = 0
        },
        {
            key = "type",
            name = _("Type"),
            values = {_("Left"), _("Wye"), _("Right")},
            defaultIndex = 0
        },
        {
            key = "compa",
            name = _("Compactness"),
            values = {_("Standard"), _("Medium"), _("Compact")},
            defaultIndex = 0,
        },
        {
            key = "cot",
            name = "1/#",
            values = func.map(func.map(sizeSwitch, math.floor), tostring),
            defaultIndex = 5
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "wallAHeight",
            name = sp .. "\n" .. _("Wall A") .. "\n" .. _("Height") .. "(m)",
            values = pipe.new * {"↓", _("None")} + func.seqMap({1, 15}, tostring),
            defaultIndex = 1
        },
        {
            key = "wallAVar",
            name = _("Variance") .. "(m)",
            values = func.seqMap({-12, 12}, tostring),
            defaultIndex = 12
        },
        {
            key = "wallAType",
            name = _("Type"),
            values = {_("Concrete"), _("Stone brick"), _("Arch"), _("Noise barrier")},
            defaultIndex = 0
        },
        {
            key = "wallBHeight",
            name = sp .. "\n" .. _("Wall B") .. "\n" .. _("Height") .. "(m)",
            values = pipe.new * {"↓", _("None")} + func.seqMap({1, 15}, tostring),
            defaultIndex = 1
        },
        {
            key = "wallBVar",
            name = _("Variance") .. "(m)",
            values = func.seqMap({-12, 12}, tostring),
            defaultIndex = 12
        },
        {
            key = "wallBType",
            name = _("Type"),
            values = {_("Sync"), _("Concrete"), _("Stone brick"), _("Arch"), _("Noise barrier")},
            defaultIndex = 0
        },
        {
            key = "wallOffset",
            name = sp .. "\n" .. "Wall-Track distance",
            values = func.seqMap({0, 8}, function(n) return tostring(n * 0.5) end),
            defaultIndex = 1
        },
        {
            key = "terrain",
            name = _("Terrain Alignment"),
            values = {_("Normal"), _("Sharp"), _("Complet")},
            defaultIndex = 0
        },
        {
            key = "height",
            name = _("Altitude Adjustment") .. "(m)",
            values = func.seqMap({-10, 15}, tostring),
            defaultIndex = 10
        }
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    func.forEach(params(), function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end

local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local nbTracks = params.nbTracks + 1
        local offsets = junction.buildCoors(nbTracks, nbTracks)
        
        local rad = atan(1 / sizeSwitch[params.cot + 1])
        local r = 1.435 * 0.5 / sin(0.5 * rad) ^ 2 + 2.5 * (nbTracks - 1)
        
        local radious = {
            l = params.type == 2 and junction.infi or r,
            r = params.type == 0 and junction.infi or r
        }
        
        local compactness = ({0, -1.25, -1.625})[params.compa + 1]
        
        local guidelines = {
            l = arc.byOR(coor.xy(-radious.l, 0), radious.l),
            r = arc.byOR(coor.xy(radious.r, 0), radious.r),
        }
        
        local limArc = {
            l = guidelines.l + 2.5 * nbTracks + compactness,
            r = guidelines.r + 2.5 * nbTracks + compactness,
        }
        
        local initRad = {
            l = 0,
            r = pi
        }
        
        local finalRad = {
            l = limArc.l:rad((func.filter(limArc.l - limArc.r, function(p) return p.y > 0 end))[1]),
            r = limArc.r:rad((func.filter(limArc.l - limArc.r, function(p) return p.y > 0 end))[1])
        }
        
        local radc = 5 / junction.infi
        
        guidelines = {
            l = guidelines.l:withLimits({
                sup = finalRad.l,
                mid = initRad.l,
                inf = -finalRad.l
            }),
            r = guidelines.r:withLimits({
                sup = finalRad.r,
                mid = initRad.r,
                inf = -finalRad.r
            }),
            c = arc.byOR(coor.xy(-junction.infi, 0), junction.infi):withLimits({
                sup = radc,
                mid = 0,
                inf = -radc
            })
        }
        
        local slope = slopeList[params.slope + 1] * (params.slopeSign == 0 and 1 or -1) * 0.001
        
        local fz = {
            l = function(rad) return {z = guidelines.l:pt(rad).y * slope, s = slope} end,
            r = function(rad) return {z = guidelines.r:pt(rad).y * slope, s = slope} end,
            c = function(rad) return {z = guidelines.c:pt(rad).y * slope, s = slope} end,
        }
        
        
        local arcs = offsets.tracks
            * pipe.map(function(o) return {
                l = guidelines.l + o,
                r = guidelines.r + (-o),
                c = guidelines.c + o
            } end
            )
            * function(g)
                local l = g * pipe.map(pipe.select("l"))
                local r = g * pipe.map(pipe.select("r"))
                return
                    {
                        c = g * pipe.map(pipe.select("c")),
                        l = l
                        * pipe.mapi(function(g, i)
                            local rads = r * pipe.range(1, i - 1)
                                * pipe.map(function(y) return pipe.new * (g - y) end)
                                * pipe.map(pipe.filter(function(pt) return pt.y > 0 end))
                                * pipe.flatten()
                                * pipe.rev()
                                * pipe.map(function(p) return g:rad(p) end)
                            return (pipe.new + {initRad.l} + rads)
                                * pipe.map2(rads / finalRad.l, function(l, r)
                                    return g:withLimits({
                                        sup = r,
                                        mid = l,
                                        inf = initRad.l - radc
                                    })
                                end)
                        end),
                        r = r
                        * pipe.mapi(function(g, i)
                            local rads = l * pipe.range(i + 1, #l)
                                * pipe.map(function(y) return pipe.new * (g - y) end)
                                * pipe.map(pipe.filter(function(pt) return pt.y > 0 end))
                                * pipe.flatten()
                                * pipe.map(function(p) return g:rad(p) end)
                            return (pipe.new + {initRad.r} + rads)
                                * pipe.map2(rads / finalRad.r, function(l, r)
                                    return g:withLimits({
                                        sup = r,
                                        mid = l,
                                        inf = initRad.r + radc
                                    })
                                end)
                        end)
                    }
            end
            * function(g)
                local larc = g.l * pipe.map(pipe.map(generateArc(fz.l))) * pipe.map(pipe.map(pipe.select(2)))
                local rarc = g.r * pipe.map(pipe.map(generateArc(fz.r))) * pipe.map(pipe.map(pipe.select(2)))
                    * pipe.mapi(function(g, i)
                        return pipe.new * g * pipe.mapi(function(a, j)
                            return {
                                larc[j + i - 1][j][1],
                                (j + i) > #larc and a[2] or larc[i + j][j][2],
                                a[3], a[4]
                            }
                        end)
                    end)
                local carc = g.c * pipe.map(generateArc(fz.c)) * pipe.map(pipe.select(1))
                return (larc + rarc)
                    * pipe.map(function(a) return {
                        edge = pipe.new * a,
                        snap = pipe.new * func.seq(1, #a - 1) * pipe.map(function(_) return {false, false} end) / {false, true}
                    } end)
                    / {
                        edge = carc,
                        snap = carc * pipe.map(function(_) return {true, false} end)
                    }
            end
            * station.mergeEdges
        
        
        local wallHeight = {
            A = func.seq(-1, 15)[params.wallAHeight + 1],
            B = func.seq(-1, 15)[params.wallBHeight + 1]
        }
        
        local wallGuidelines = offsets.walls *
            pipe.map2({guidelines.l, guidelines.r}, function(o, g) return g + (-abs(o) + params.wallOffset * 0.5) end)
            / (guidelines.c + (-abs(offsets.walls[1] + params.wallOffset * 0.5)))
            / (guidelines.c + (abs(offsets.walls[2] - params.wallOffset * 0.5)))
        
        local restrictedWallGuidelines = offsets.walls
            * pipe.map2({guidelines.l, guidelines.r}, function(o, g) return g + (-abs(o) + params.wallOffset * 0.5 - 1) end)
            / (guidelines.c + (-abs(offsets.walls[1] + params.wallOffset * 0.5 - 1)))
            / (guidelines.c + (abs(offsets.walls[2] - params.wallOffset * 0.5 + 1)))
        
        local wallLimitGuidelines = offsets.walls
            * pipe.map2({guidelines.l, guidelines.r}, function(o, g) return
                {
                    g + (-abs(o) + params.wallOffset * 2.5),
                    g + (-abs(o) + params.wallOffset * 10)
                }
            end)
            / {
            (guidelines.c + (-abs(offsets.walls[1] + params.wallOffset * 2.5))),
                (guidelines.c + (-abs(offsets.walls[1] + params.wallOffset * 10))),
            }
            / {
            (guidelines.c + (abs(offsets.walls[2] - params.wallOffset * 2.5))),
                (guidelines.c + (abs(offsets.walls[2] - params.wallOffset * 10))),
            }
        
        local polys = pipe.new
            / {g = {wallGuidelines[1], guidelines.l}, o = wallHeight.A < 0 and -1 or 1}
            / {g = {guidelines.r, wallGuidelines[2]}, o = wallHeight.B < 0 and -1 or 1}
            * pipe.map(function(g) return junction.generatePolyArc(g.g, "mid", "sup")(-0.2, g.o) end)
            * pipe.map(pipe.map(pipe.map(function(p) return coor.transZ(p.y * slope)(p) end)))
            +
            pipe.new
            / {g = {wallGuidelines[3], guidelines.c}, o = wallHeight.A < 0 and -1 or 1}
            / {g = {guidelines.c, wallGuidelines[4]}, o = wallHeight.B < 0 and -1 or 1}
            * pipe.map(function(g) return junction.generatePolyArc(g.g, "inf", "mid")(-0.2, g.o) end)
            * pipe.map(pipe.map(pipe.map(function(p) return coor.transZ(p.y * slope)(p) end)))
        
        local polysP = pipe.new
            / {wallGuidelines[1], guidelines.l}
            / {guidelines.r, wallGuidelines[2]}
            * pipe.map(function(g) return junction.generatePolyArc(g, "mid", "sup")(-0.2, 1) end)
            * pipe.map(pipe.map(pipe.map(function(p) return coor.transZ(p.y * slope)(p) end)))
            +
            pipe.new
            / {wallGuidelines[3], guidelines.c}
            / {guidelines.c, wallGuidelines[4]}
            * pipe.map(function(g) return junction.generatePolyArc(g, "inf", "mid")(-0.2, 1) end)
            * pipe.map(pipe.map(pipe.map(function(p) return coor.transZ(p.y * slope)(p) end)))
        
        local polysO = pipe.new
            / wallLimitGuidelines[1]
            / wallLimitGuidelines[2]
            * pipe.map(function(g) return junction.generatePolyArc(g, "mid", "sup")(-0.2, 1) end)
            * pipe.map(pipe.map(pipe.map(function(p) return coor.transZ(p.y * slope)(p) end)))
            +
            pipe.new
            / wallLimitGuidelines[3]
            / wallLimitGuidelines[4]
            * pipe.map(function(g) return junction.generatePolyArc(g, "inf", "mid")(-0.2, 1) end)
            * pipe.map(pipe.map(pipe.map(function(p) return coor.transZ(p.y * slope)(p) end)))
        
        local vfz = function(h, va)
            return nil
        -- local var = h < 0 and 0 or
        --     va + h > 15 and 15 - h or
        --     va + h < 0 and -h or va
        -- local ln = line.byPtPt(coor.xy(initRad, 0), coor.xy(initRad + dRad, var))
        -- return function(rad) return {z = (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y, s = (-ln.a / ln.b) / length * dRad} end
        end
        
        local function mPlace(fz, vfz)
            return function(guideline, rad1, rad2)
                local rad = rad2 and (rad1 + rad2) * 0.5 or rad1
                local z = fz(rad).z
                local s = -fz(rad).s
                local pt = guideline:pt(rad)
                return coor.shearZoY(s) * coor.transZ(z) * coor.rotZ(rad) * coor.trans(func.with(pt, {z = 0}))
            end
        end
        
        local retriveWall = {
            A = function(ls) return ls[params.wallAType + 1] end,
            B = function(ls) return params.wallBType == 0 and ls[params.wallAType + 1] or ls[params.wallBType] end
        }
        
        local makeWallA = function(fz)
            return junction.makeFn(
                retriveWall.A(wallList),
                mPlace(fz, vfz(wallHeight.A, func.seq(-12, 12)[params.wallAVar + 1])),
                retriveWall.A(wallTransList)(wallHeight.A) * (wallHeight.A < 1 and coor.flipX() or coor.I()),
                retriveWall.A(wallLengthList))
        end
        
        local makeWallB = function(fz)
            return junction.makeFn(
                retriveWall.B(wallList),
                mPlace(fz, vfz(wallHeight.B, func.seq(-12, 12)[params.wallBVar + 1])),
                retriveWall.B(wallTransList)(wallHeight.B) * (wallHeight.B < 1 and coor.flipX() or coor.I()),
                retriveWall.B(wallLengthList))
        end
        
        local makeWallBc = function(fz)
            return junction.makeFn(
                retriveWall.B(wallList),
                mPlace(fz, vfz(wallHeight.B, func.seq(-12, 12)[params.wallBVar + 1])),
                retriveWall.B(wallTransList)(wallHeight.B) * coor.flipX() * (wallHeight.B < 1 and coor.flipX() or coor.I()),
                retriveWall.B(wallLengthList))
        end
        
        local walls = pipe.new
            + {wallHeight.A == 0 and {} or pipe.new * wallGuidelines[1] * makeWallA(fz.l) * pipe.select(2)}
            + {wallHeight.B == 0 and {} or pipe.new * wallGuidelines[2] * makeWallB(fz.r) * pipe.select(2)}
            + {wallHeight.A < 0 and pipe.new * restrictedWallGuidelines[1] * makeWallA(fz.l) * pipe.select(2) or {}}
            + {wallHeight.B < 0 and pipe.new * restrictedWallGuidelines[2] * makeWallB(fz.r) * pipe.select(2) or {}}
            + {wallHeight.A == 0 and {} or pipe.new * wallGuidelines[3] * makeWallA(fz.c) * pipe.select(1)}
            + {wallHeight.B == 0 and {} or pipe.new * wallGuidelines[4] * makeWallBc(fz.c) * pipe.select(1)}
            + {wallHeight.A < 0 and pipe.new * restrictedWallGuidelines[3] * makeWallA(fz.c) * pipe.select(1) or {}}
            + {wallHeight.B < 0 and pipe.new * restrictedWallGuidelines[4] * makeWallBc(fz.c) * pipe.select(1) or {}}
        
        return
            pipe.new
            * {
                edgeLists =
                {
                    pipe.new * {arcs} * station.prepareEdges * trackBuilder.nonAligned(),
                },
                terrainAlignmentLists = station.mergePoly(
                    (
                    {
                        {
                            equal = station.projectPolys(coor.I())(polys * pipe.flatten())
                        },
                        {
                            less =
                            station.projectPolys(coor.transZ(wallHeight.A > 0 and wallHeight.A or 0))(polys[1])
                            + station.projectPolys(coor.transZ(wallHeight.B > 0 and wallHeight.B or 0))(polys[2]),
                            platform = station.projectPolys(coor.I())(polys * pipe.flatten()),
                            slot = station.projectPolys(coor.I())(polysP * pipe.flatten())
                        },
                        {
                            less =
                            station.projectPolys(coor.transZ(wallHeight.A > 0 and wallHeight.A or 0))(polys[1])
                            + station.projectPolys(coor.transZ(wallHeight.B > 0 and wallHeight.B or 0))(polys[2]),
                            platform = station.projectPolys(coor.I())(polys * pipe.flatten())
                            + (wallHeight.A > 0 and station.projectPolys(coor.transZ(wallHeight.A))(polysO[1]) or {})
                            + (wallHeight.B > 0 and station.projectPolys(coor.transZ(wallHeight.B))(polysO[2]) or {}),
                            slot = station.projectPolys(coor.I())(polysP * pipe.flatten())
                        }
                    }
                    )[params.terrain + 1]
                )({less = 1.5}),
                models = walls * pipe.flatten(),
            }
            * station.setHeight(func.seq(-10, 15)[params.height + 1])
    end
end


function data()
    return {
        type = "RAIL_DEPOT",
        description = {
            name = _("Switches"),
            description = _("A compact tunnel entry")
        },
        availability = {
            yearFrom = 1892
        },
        -- buildMode = "SINGLE",
        -- categories = {"misc"},
        order = 27218,
        -- skipCollision = false,
        -- autoRemovable = false,
        params = params(),
        updateFn = updateFn()
    }

end
