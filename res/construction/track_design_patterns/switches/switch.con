local paramsutil = require "paramsutil"
local func = require "track_design_patterns/func"
local coor = require "track_design_patterns/coor"
local line = require "track_design_patterns/coorline"
local arc = require "track_design_patterns/coorarc"
local trackEdge = require "track_design_patterns/trackedge"
local station = require "track_design_patterns/stationlib"
local pipe = require "track_design_patterns/pipe"
local junction = require "junction"
local dump = require "datadumper"
local abs = math.abs
local pi = math.pi
local atan = math.atan
local cos = math.cos
local sin = math.sin

local generateArc = function(fz)
    return function(arc)
        local toXyz = function(pt, z) return coor.xyz(pt.x, pt.y, z) end
        
        local sup = toXyz(arc:pt(arc.sup), fz(arc.sup).z)
        local inf = toXyz(arc:pt(arc.inf), fz(arc.inf).z)
        local mid = toXyz(arc:pt(arc.mid), fz(arc.mid).z)
        
        local vecSup = func.with(arc:tangent(arc.sup), {z = fz(arc.sup).s})
        local vecInf = func.with(arc:tangent(arc.inf), {z = fz(arc.inf).s})
        local vecMid = func.with(arc:tangent(arc.mid), {z = fz(arc.mid).s})
        
        return {
            {inf, mid, vecInf, vecMid},
            {mid, sup, vecMid, vecSup}
        }
    end
end

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local wallList = {
    "track_design_patterns/concrete_wall.mdl",
    "track_design_patterns/brick_wall.mdl",
    "track_design_patterns/arch_wall.mdl",
    "asset/track_multi_sound_insulation_10m.mdl"
}
local wallHeightList = {15, 15, 15, 8}
local wallLengthList = {5, 5, 5, 10}
local wallTransList = {
    function(h) return coor.scaleX(2) * coor.transX(-0.5) * coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.scaleX(2) * coor.transX(-0.5) * coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.scaleX(2) * coor.transX(-0.5) * coor.transZ((h > 0 and h or 0) - 10) end,
    function(h) return coor.transY(3.2) * coor.rotZ(pi * 0.5) * coor.transZ((h > 8 and 8 or abs(h)) - 5.1) end
}

local sizeSwitch = {4.03, 5, 6, 7, 9, 12, 18, 24, 30, 36, 42, 50, 65}

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6")},
            defaultIndex = 0
        },
        {
            key = "type",
            name = _("Type"),
            values = {_("Left"), _("Wye"), _("Right")},
            defaultIndex = 0
        },
        {
            key = "compa",
            name = _("Compactness"),
            values = {_("Standard"), _("Medium"), _("Compact")},
            defaultIndex = 0,
        },
        {
            key = "cot",
            name = "1/#",
            values = func.map(func.map(sizeSwitch, math.floor), tostring),
            defaultIndex = 5
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "wallAHeight",
            name = sp .. "\n" .. _("Wall A") .. "\n" .. _("Height") .. "(m)",
            values = pipe.new * {"↓", _("None")} + func.seqMap({1, 15}, tostring),
            defaultIndex = 1
        },
        {
            key = "wallAType",
            name = _("Type"),
            values = {_("Concrete"), _("Stone brick"), _("Arch"), _("Noise barrier")},
            defaultIndex = 0
        },
        {
            key = "wallBHeight",
            name = sp .. "\n" .. _("Wall B") .. "\n" .. _("Height") .. "(m)",
            values = pipe.new * {_("Sync"), "↓", _("None")} + func.seqMap({1, 15}, tostring),
            defaultIndex = 0
        },
        {
            key = "wallBType",
            name = _("Type"),
            values = {_("Sync"), _("Concrete"), _("Stone brick"), _("Arch"), _("Noise barrier")},
            defaultIndex = 0
        },
        {
            key = "wallOffset",
            name = sp .. "\n" .. "Wall-Track distance",
            values = func.seqMap({0, 8}, function(n) return tostring(n * 0.5) end),
            defaultIndex = 1
        },
        {
            key = "terrain",
            name = _("Terrain Alignment"),
            values = {_("Normal"), _("Sharp"), _("Complet")},
            defaultIndex = 0
        },
        {
            key = "height",
            name = _("Altitude Adjustment") .. "(m)",
            values = func.seqMap({-10, 15}, tostring),
            defaultIndex = 10
        }
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    func.forEach(params(), function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end

local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local nbTracks = params.nbTracks + 1
        local offsets = junction.buildCoors(nbTracks, nbTracks)
        local wallOffset = params.wallOffset * 0.5
        
        local rad = atan(1 / sizeSwitch[params.cot + 1])
        local r = 1.435 * 0.5 / sin(0.5 * rad) ^ 2 + 2.5 * (nbTracks - 1)
        
        local radious = {
            l = params.type == 2 and junction.infi or r,
            r = params.type == 0 and junction.infi or r
        }
        
        local compactness = ({0, -1.25, -1.625})[params.compa + 1]
        
        local guidelines = {
            l = arc.byOR(coor.xy(-radious.l, 0), radious.l),
            r = arc.byOR(coor.xy(radious.r, 0), radious.r),
        }
        
        local limArc = {
            l = guidelines.l + 2.5 * nbTracks + compactness,
            r = guidelines.r + 2.5 * nbTracks + compactness,
        }
        
        local initRad = {
            l = 0,
            r = pi
        }
        
        local finalRad = {
            l = limArc.l:rad((func.filter(limArc.l - limArc.r, function(p) return p.y > 0 end))[1]),
            r = limArc.r:rad((func.filter(limArc.l - limArc.r, function(p) return p.y > 0 end))[1])
        }
        
        local radc = 5 / junction.infi
        
        guidelines = {
            l = guidelines.l:withLimits({
                sup = finalRad.l,
                mid = initRad.l,
                inf = -finalRad.l
            }),
            r = guidelines.r:withLimits({
                sup = finalRad.r,
                mid = initRad.r,
                inf = -finalRad.r
            }),
            c = arc.byOR(coor.xy(-junction.infi, 0), junction.infi):withLimits({
                sup = radc,
                mid = 0,
                inf = -radc
            })
        }
        
        local slope = slopeList[params.slope + 1] * (params.slopeSign == 0 and 1 or -1) * 0.001
        
        local fz = {
            l = function(rad) return {z = guidelines.l:pt(rad).y * slope, s = slope} end,
            r = function(rad) return {z = guidelines.r:pt(rad).y * slope, s = slope} end,
            c = function(rad) return {z = guidelines.c:pt(rad).y * slope, s = slope} end,
        }
        
        
        local arcs = offsets.tracks
            * pipe.map(function(o) return {
                l = guidelines.l + o,
                r = guidelines.r + (-o),
                c = guidelines.c + o
            } end
            )
            * function(g)
                local l = g * pipe.map(pipe.select("l"))
                local r = g * pipe.map(pipe.select("r"))
                return
                    {
                        c = g * pipe.map(pipe.select("c")),
                        l = l
                        * pipe.mapi(function(g, i)
                            local rads = r * pipe.range(1, i - 1)
                                * pipe.map(function(y) return pipe.new * (g - y) end)
                                * pipe.map(pipe.filter(function(pt) return pt.y > 0 end))
                                * pipe.flatten()
                                * pipe.rev()
                                * pipe.map(function(p) return g:rad(p) end)
                            return (pipe.new + {initRad.l} + rads)
                                * pipe.map2(rads / finalRad.l, function(l, r)
                                    return g:withLimits({
                                        sup = r,
                                        mid = l,
                                        inf = initRad.l - radc
                                    })
                                end)
                        end),
                        r = r
                        * pipe.mapi(function(g, i)
                            local rads = l * pipe.range(i + 1, #l)
                                * pipe.map(function(y) return pipe.new * (g - y) end)
                                * pipe.map(pipe.filter(function(pt) return pt.y > 0 end))
                                * pipe.flatten()
                                * pipe.map(function(p) return g:rad(p) end)
                            return (pipe.new + {initRad.r} + rads)
                                * pipe.map2(rads / finalRad.r, function(l, r)
                                    return g:withLimits({
                                        sup = r,
                                        mid = l,
                                        inf = initRad.r + radc
                                    })
                                end)
                        end)
                    }
            end
            * function(g)
                local larc = g.l * pipe.map(pipe.map(generateArc(fz.l))) * pipe.map(pipe.map(pipe.select(2)))
                local rarc = g.r * pipe.map(pipe.map(generateArc(fz.r))) * pipe.map(pipe.map(pipe.select(2)))
                    * pipe.mapi(function(g, i)
                        return pipe.new * g * pipe.mapi(function(a, j)
                            return {
                                larc[j + i - 1][j][1],
                                (j + i) > #larc and a[2] or larc[i + j][j][2],
                                a[3], a[4]
                            }
                        end)
                    end)
                local carc = g.c * pipe.map(generateArc(fz.c)) * pipe.map(pipe.select(1))
                return (larc + rarc)
                    * pipe.map(function(a) return {
                        edge = pipe.new * a,
                        snap = pipe.new * func.seq(1, #a - 1) * pipe.map(function(_) return {false, false} end) / {false, true}
                    } end)
                    / {
                        edge = carc,
                        snap = carc * pipe.map(function(_) return {true, false} end)
                    }
            end
            * station.mergeEdges
        
        local retriveWall = {
            A = function(ls) return ls[params.wallAType + 1] end,
            B = function(ls) return params.wallBType == 0 and ls[params.wallAType + 1] or ls[params.wallBType] end
        }
        
        
        local wallHeight = {
            A = func.seq(-1, 15)[params.wallAHeight + 1],
            B = params.wallBHeight == 0 and func.seq(-1, 15)[params.wallAHeight + 1] or func.seq(-1, 15)[params.wallBHeight]
        }
        
        local wallGuidelines = offsets.walls *
            pipe.map2({guidelines.l, guidelines.r}, function(o, g) return g + (-abs(o) + wallOffset) end)
            / (guidelines.c + (-abs(offsets.walls[1] + wallOffset)))
            / (guidelines.c + (abs(offsets.walls[2] - wallOffset)))
        
        local restrictedWallGuidelines =
            {
                guidelines.l + (offsets.tracks[1] - 0.75),
                guidelines.r + (-offsets.tracks[#offsets.tracks] - 0.75),
                guidelines.c + (offsets.tracks[1] - 0.75),
                guidelines.c + (offsets.tracks[#offsets.tracks] + 0.75),
            }
        
        local terrainGuidelines = {
            l = offsets.walls
            * pipe.map(function(o)
                local ref = guidelines.l + o
                local extra = function(w) return ref + (o > 0 and w or -w) end
                return
                    {
                        ref = ref,
                        outer = extra(wallOffset + 1),
                        inner = extra(wallOffset - 1)
                    }
            end)
            * (function(r) return
                {
                    ref = func.map(r, pipe.select("ref")),
                    outer = func.map(r, pipe.select("outer")),
                    inner = func.map(r, pipe.select("inner")),
                } end),
            r = offsets.walls
            * pipe.map(function(o)
                local ref = guidelines.r + (-o)
                local extra = function(w) return ref + (o < 0 and w or -w) end
                return
                    {
                        ref = ref,
                        outer = extra(wallOffset + 1),
                        inner = extra(wallOffset - 1)
                    }
            end)
            * (function(r) return
                {
                    ref = func.map(r, pipe.select("ref")),
                    outer = func.map(r, pipe.select("outer")),
                    inner = func.map(r, pipe.select("inner")),
                } end),
            c = offsets.walls
            * pipe.map(function(o)
                local ref = guidelines.c + o
                local extra = function(w) return ref + (o > 0 and w or -w) end
                return
                    {
                        ref = ref,
                        outer = extra(wallOffset + 1),
                        inner = extra(wallOffset - 1)
                    }
            end)
            * (function(r) return
                {
                    ref = func.map(r, pipe.select("ref")),
                    outer = func.map(r, pipe.select("outer")),
                    inner = func.map(r, pipe.select("inner")),
                } end)
        }
        
        local polyGen = function(wallHeight, refHeight, guidelines, wHeight, fr, to)
            local f = function(s) return s.g and
                junction.generatePolyArc(s.g, fr, to)(-0.2, 0)
                * pipe.map(pipe.map(s.fz))
                * station.projectPolys(coor.I())
                or {}
            end
            local polyGen = function(l, e, g)
                return wallHeight == 0 and f(e) or (wallHeight > 0 and f(g) or f(l))
            end
            
            return {
                slot = polyGen(
                    {},
                    {},
                    {g = guidelines.outer, fz = function(p) return coor.transZ(p.y * slope)(p) end}
                ),
                equal = polyGen(
                    {},
                    refHeight > 0 and {} or {g = guidelines.ref, fz = function(p) return coor.transZ(p.y * slope)(p) end},
                    {}
                ),
                less = polyGen(
                    {g = guidelines.outer, fz = function(p) return coor.transZ(p.y * slope)(p) end},
                    refHeight > 0 and {g = guidelines.ref, fz = function(p) return coor.transZ(p.y * slope)(p) end} or {},
                    {g = guidelines.outer, fz = function(p) return coor.transZ(p.y * slope + wallHeight)(p) end}
                ),
                greater = polyGen(
                    {g = guidelines.outer, fz = function(p) return coor.transZ(p.y * slope - wHeight)(p) end},
                    refHeight > 0 and {g = guidelines.ref, fz = function(p) return coor.transZ(p.y * slope)(p) end} or {},
                    refHeight ~= 0 and {g = guidelines.outer, fz = function(p) return coor.transZ(p.y * slope - wHeight + wallHeight)(p) end} or {}
                ),
                platform = polyGen(
                    refHeight ~= 0 and {g = guidelines.inner, fz = function(p) return coor.transZ(p.y * slope)(p) end} or {},
                    {},
                    refHeight ~= 0 and {g = guidelines.inner, fz = function(p) return coor.transZ(p.y * slope)(p) end} or {}
            )
            }
        end
        
        local polys = station.mergePoly(
            polyGen(wallHeight.A, wallHeight.B, terrainGuidelines.l, retriveWall.A(wallHeightList), "mid", "sup"),
            polyGen(wallHeight.B, wallHeight.A, terrainGuidelines.r, retriveWall.B(wallHeightList), "mid", "sup")
        )({less = 1.5})
        
        local function mPlace(fz)
            return function(guideline, rad1, rad2)
                local rad = rad2 and (rad1 + rad2) * 0.5 or rad1
                local z = fz(rad).z
                local s = -fz(rad).s
                local pt = guideline:pt(rad)
                return coor.shearZoY(s) * coor.transZ(z) * coor.rotZ(rad) * coor.trans(func.with(pt, {z = 0}))
            end
        end
        
        local makeWallA = function(fz)
            return junction.makeFn(
                retriveWall.A(wallList),
                mPlace(fz),
                retriveWall.A(wallTransList)(wallHeight.A) * (wallHeight.A < 0 and coor.flipX() or coor.I()),
                retriveWall.A(wallLengthList))
        end
        
        local makeWallB = function(fz)
            return junction.makeFn(
                retriveWall.B(wallList),
                mPlace(fz),
                retriveWall.B(wallTransList)(wallHeight.B) * (wallHeight.B > 0 and coor.flipX() or coor.I()),
                retriveWall.B(wallLengthList))
        end
        
        local makeWallBc = function(fz)
            return junction.makeFn(
                retriveWall.B(wallList),
                mPlace(fz),
                retriveWall.B(wallTransList)(wallHeight.B) * coor.flipX() * (wallHeight.B < 1 and coor.flipX() or coor.I()),
                retriveWall.B(wallLengthList))
        end
        
        
        local makePaving = function(fz)
            return junction.makeFn(
                "track_design_patterns/paving_base.mdl",
                mPlace(fz),
                coor.transZ(0),
                5)
        end
        
        
        local walls = pipe.new
            + {wallHeight.A == 0 and {} or pipe.new * wallGuidelines[1] * makeWallA(fz.l) * pipe.select(2)}
            + {wallHeight.B == 0 and {} or pipe.new * wallGuidelines[2] * makeWallB(fz.r) * pipe.select(2)}
            + {wallHeight.A ~= 0 and pipe.new * restrictedWallGuidelines[1] * makePaving(fz.l) * pipe.select(2) or {}}
            + {wallHeight.B ~= 0 and pipe.new * restrictedWallGuidelines[2] * makePaving(fz.r) * pipe.select(2) or {}}
            + {wallHeight.A == 0 and {} or pipe.new * wallGuidelines[3] * makeWallA(fz.c) * pipe.select(1)}
            + {wallHeight.B == 0 and {} or pipe.new * wallGuidelines[4] * makeWallBc(fz.c) * pipe.select(1)}
            + {wallHeight.A ~= 0 and pipe.new * restrictedWallGuidelines[3] * makePaving(fz.c) * pipe.select(1) or {}}
            + {wallHeight.B ~= 0 and pipe.new * restrictedWallGuidelines[4] * makePaving(fz.c) * pipe.select(1) or {}}
        
        return
            pipe.new
            * {
                edgeLists = {pipe.new * {arcs} * station.prepareEdges * trackBuilder.nonAligned()},
                terrainAlignmentLists = polys,
                models = walls * pipe.flatten(),
            }
            * station.setHeight(func.seq(-10, 15)[params.height + 1])
    end
end


function data()
    return {
        type = "RAIL_DEPOT",
        description = {
            name = _("Switches"),
            description = _("A compact tunnel entry")
        },
        availability = {
            yearFrom = 1892
        },
        -- buildMode = "SINGLE",
        -- categories = {"misc"},
        order = 27218,
        -- skipCollision = false,
        -- autoRemovable = false,
        params = params(),
        updateFn = updateFn()
    }

end
