local paramsutil = require "paramsutil"
local func = require "flyingjunction/func"
local coor = require "flyingjunction/coor"
local trackEdge = require "flyingjunction/trackedge"
local line = require "flyingjunction/coorline"
local arc = require "flyingjunction/coorarc"
local station = require "flyingjunction/stationlib"
local pipe = require "flyingjunction/pipe"
local junction = require "junction"
local jA = require "junction_assoc"
local jM = require "junction_main"
local dump = require "datadumper"
local pi = math.pi
local abs = math.abs

local rList = {junction.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}
local slopeList = {15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 80, 90, 100}
local wallList = {
    "track_design_patterns/concrete_wall.mdl",
    "track_design_patterns/brick_wall.mdl",
    "track_design_patterns/arch_wall.mdl",
}

local function params()
    local sp = "----------------------------\n"
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), },
            defaultIndex = 1
        },
        {
            key = "signS",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radiusS",
            name = _("Surface Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "lengthS",
            name = _("Surface Length") .. "(%)",
            values = func.map(func.seq(1, 10), function(r) return tostring(r * 10) end),
            defaultIndex = 9
        },
        {
            key = "signU",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radiusU",
            name = _("Underground Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope(‰)"),
            values = func.map(slopeList, tostring),
            defaultIndex = #slopeList - 1
        },
        {
            key = "paraTracks",
            name = sp .. _("Parellal tracks"),
            values = {_("None"), _("Both"), _("Left"), _("Right")},
            defaultIndex = 1
        }
    }

end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    
    func.forEach(params(), function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end

local updateFn = function(models)
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local height = 8.5
        
        local nbTracks = params.nbTracks + 1
        local slope = (params.slopeSign == 0 and 1 or -1) * slopeList[params.slope + 1] * 0.001
        
        local offsets = junction.buildCoors(nbTracks, nbTracks)
        local radius = {
            surface = (rList[params.radiusS + 1] * 1000) * (params.signS == 0 and 1 or -1),
            underground = (rList[params.radiusU + 1] * 1000) * (params.signU == 0 and 1 or -1)
        }
        
        local length = 8.5 / abs(slope)
        
        local radInit = {
            surface = radius.surface > 0 and pi or 0,
            underground = radius.underground > 0 and pi or 0
        }
        
        local radFinal = {
            surface = length / radius.surface * (params.lengthS + 1) * 0.1,
            underground = length / radius.underground
        }
        
        local limits = {
            surface = {
                sup = radInit.surface,
                mid = radInit.surface + radFinal.surface - 2.5 / radius.surface,
                inf = radInit.surface + radFinal.surface
            },
            underground = {
                sup = radInit.underground - radFinal.underground,
                mid = radInit.underground - radFinal.underground * 0.5,
                inf = radInit.underground
            },
            side = {
                sup = radInit.surface - 5 / radius.surface,
                mid = radInit.surface - 3 / radius.surface,
                inf = radInit.surface + radFinal.surface - 5 / radius.surface
            }
        }
        
        local guideline = {
            surface = arc.byOR(coor.xy(radius.surface, 0), radius.surface):withLimits(limits.surface),
            underground = arc.byOR(coor.xy(radius.underground, 0), radius.underground):withLimits(limits.underground),
            side = arc.byOR(coor.xy(radius.underground, 0), radius.underground):withLimits(limits.side),
        }
        
        local guidelines = {
            surface = offsets.tracks * pipe.map(function(o) return guideline.surface + o * (radius.surface > 0 and -1 or 1) end),
            underground = offsets.tracks * pipe.map(function(o) return guideline.underground + o * (radius.underground > 0 and -1 or 1) end),
            side = pipe.new * {offsets.tracks[1] - 5.75, offsets.tracks[#offsets.tracks] + 5.75}
            * pipe.map(function(o) return guideline.side + o * (radius.surface > 0 and -1 or 1) end)
        }
        
        local fz = {
            surface = pipe.exec * function()
                local ln = line.byPtPt(coor.xy(radInit.surface, -height), coor.xy(radInit.surface + radFinal.surface, 0))
                return function(rad) return {z = (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y, s = -slope} end
            end,
            underground = pipe.exec * function()
                local ln = line.byPtPt(coor.xy(radInit.underground, -height), coor.xy(radInit.underground - radFinal.underground, -2 * height))
                return function(rad) return {z = (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y, s = -slope} end
            end
        }
        
        local zsList = {
            surface = {
                {
                    coor.transZ(fz.surface(limits.surface.inf).z),
                    coor.transZ(fz.surface(limits.surface.mid).z),
                    coor.transZ(fz.surface(limits.surface.inf).s),
                    coor.transZ(fz.surface(limits.surface.mid).s)
                },
                {
                    coor.transZ(fz.surface(limits.surface.mid).z),
                    coor.transZ(fz.surface(limits.surface.sup).z),
                    coor.transZ(fz.surface(limits.surface.mid).s),
                    coor.transZ(fz.surface(limits.surface.sup).s)
                }
            },
            underground = {
                {
                    coor.transZ(fz.underground(limits.underground.inf).z),
                    coor.transZ(fz.underground(limits.underground.mid).z),
                    coor.transZ(fz.underground(limits.underground.inf).s),
                    coor.transZ(fz.underground(limits.underground.mid).s)
                },
                {
                    coor.transZ(fz.underground(limits.underground.mid).z),
                    coor.transZ(fz.underground(limits.underground.sup).z),
                    coor.transZ(fz.underground(limits.underground.mid).s),
                    coor.transZ(fz.underground(limits.underground.sup).s)
                }
            }
        }
        
        local edges = station.fusionEdges({
            guidelines.surface
            * pipe.map(junction.generateArc)
            * pipe.map(pipe.range(1, 2))
            * pipe.map(pipe.map2(zsList.surface, function(ar, zs) return func.map2(ar, zs, coor.apply) end))
            * pipe.map(function(segs) return {edge = pipe.new * segs, snap = pipe.new / {true, false} / {false, false}} end),
            guidelines.underground
            * pipe.map(junction.generateArc)
            * pipe.map(pipe.range(1, 2))
            * pipe.map(pipe.map2(zsList.underground, function(ar, zs) return func.map2(ar, zs, coor.apply) end))
            * pipe.map(function(segs) return {edge = pipe.new * segs, snap = pipe.new / {false, false} / {false, true}} end),
            guidelines.side
            * pipe.map(junction.generateArc)
            * pipe.map(pipe.range(1, 3))
            * pipe.map(function(segs) return {edge = pipe.new * segs, snap = pipe.new / {false, false} / {false, true} / {true, false}} end),
        })
        
        local wallGuidelines = offsets.walls
            * pipe.map(function(o) return guideline.surface:extendLimits(0.5) + (o) * (radius.surface > 0 and -1 or 1) end)
        
        local polys = junction.generatePolyArc(wallGuidelines, "mid", "sup")(0.5, 2)
        local polysTracks = junction.generatePolyArc(wallGuidelines, "mid", "sup")(0.5, 1)
            * pipe.map(pipe.map(function(p) return coor.transZ(fz.surface(p.rad).z - 0.01)(p) end))
        
        local mPlace = function(guideline, rad1, rad2)
            local rad = rad2 and (rad1 + rad2) * 0.5 or rad1
            local pt = guideline:pt(rad)
            return coor.rotZ(rad) * coor.trans(func.with(pt, {z = 0}))
        end
        
        local wallType = 1
        
        local makeWallL = junction.makeFn(
            wallList[wallType],
            mPlace,
            coor.scaleX(2) * coor.transX(-0.5) * coor.transZ(-9) * (radius.surface < 0 and coor.I() or coor.flipX()),
            5)
        
        local makeWallR = junction.makeFn(
            wallList[wallType],
            mPlace,
            coor.scaleX(2) * coor.transX(-0.5) * coor.transZ(-9) * (radius.surface > 0 and coor.I() or coor.flipX()),
            5)
        
        local walls = pipe.new
            + {pipe.new * wallGuidelines[1] * makeWallL * pipe.flatten()}
            + {pipe.new * wallGuidelines[2] * makeWallR * pipe.flatten()}
            + func.map(offsets.tracks, function(o) return
                {
                    station.newModel(models.mRoofFenceF, coor.scaleY(2), coor.trans({x = o, z = -11.5, y = 0})),
                    station.newModel(models.mRoof, coor.scaleY(0.8), coor.trans({x = o, z = -11 + 0.0001, y = 2}), coor.scaleZ(0.5))
                }
            end)
            + {
                {
                    station.newModel(models.mRoof, coor.scaleY(0.8), coor.trans({x = offsets.tracks[1] - 1.25, z = -11 + 0.0001, y = 2}), coor.scaleZ(0.5)),
                    station.newModel(models.mRoof, coor.scaleY(0.8), coor.trans({x = offsets.tracks[#offsets.tracks] + 1.25, z = -11 + 0.0001, y = 2}), coor.scaleZ(0.5)),
                }
            }
        
        return {
            edgeLists = {
                pipe.new * func.map({edges[1]}, station.mergeEdges) * station.prepareEdges * trackBuilder.nonAligned(),
                pipe.new * func.map({edges[2]}, station.mergeEdges) * station.prepareEdges * trackBuilder.tunnel("void_entry.lua"),
                pipe.new / {} / func.map({edges[3]}, station.mergeEdges) / {station.mergeEdges({edges[3][1]})} / {station.mergeEdges({edges[3][2]})}
                * pipe.select(params.paraTracks + 1) * station.prepareEdges * trackBuilder.normal(),
            }
            ,
            models = walls * pipe.flatten(),
            terrainAlignmentLists = station.mergePoly(
                {
                    equal = {station.surfaceOf(coor.xyz(nbTracks * 5 + 2.5, 5, 0), coor.xyz(0, 2, 0))},
                    less = station.projectPolys(coor.I())(polys),
                    greater = station.projectPolys(coor.I())(polysTracks),
                    slot = station.projectPolys(coor.I())(polysTracks)
                }
            )() * dump.dump
            ,
            groundFaces = (pipe.new
            + polys
            * pipe.mapFlatten(function(p)
                return {
                    {face = func.map(p, coor.vec2Tuple), modes = {{type = "FILL", key = "track_design_patterns/paving_fill"}}},
                    {face = func.map(p, coor.vec2Tuple), modes = {{type = "STROKE_OUTER", key = "ballast"}}}
                }
            end)
            + {
                {
                    face = station.surfaceOf(coor.xyz(nbTracks * 5 + 2.5, 5, 0), coor.xyz(0, 2, 0)),
                    modes = {{type = "FILL", key = "track_design_patterns/paving_fill"}}
                },
                {
                    face = station.surfaceOf(coor.xyz(nbTracks * 5 + 2.5, 5, 0), coor.xyz(0, 2, 0)),
                    modes = {{type = "STROKE_OUTER", key = "ballast"}}
                }
            }
        )
        }
    end
end


function data()
    return {
        type = "ASSET_DEFAULT",
        description = {
            name = _("Compact Tunnel entry"),
            description = _("A compact tunnel entry")
        },
        availability = {
            yearFrom = 1892
        },
        buildMode = "SINGLE",
        categories = {"misc"},
        order = 27218,
        skipCollision = false,
        autoRemovable = false,
        params = params(),
        
        updateFn = updateFn(
            {
                mSidePillar = "flying_junction/concrete/pillar_side.mdl",
                mRoofFenceF = "flying_junction/concrete/roof_fence_front.mdl",
                mRoofFenceS = "flying_junction/concrete/roof_fence_side.mdl",
                mRoof = "flying_junction/concrete/roof.mdl",
                mSideOutter = "track_design_patterns/pillar_side.mdl",
                bridgeType = "z_concrete_flying_junction.lua",
            }
    )
    }

end
