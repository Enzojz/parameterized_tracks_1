local paramsutil = require "paramsutil"
local func = require "flyingjunction/func"
local coor = require "flyingjunction/coor"
local trackEdge = require "flyingjunction/trackedge"
local arc = require "flyingjunction/coorarc"
local station = require "flyingjunction/stationlib"
local pipe = require "flyingjunction/pipe"
local junction = require "junction"

local rList = {junction.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}

local abs = math.abs
local pi = math.pi

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = {_("1"), _("2"), _("3"), _("4"), _("5"), _("6"), _("7"), _("8"), _("9"), _("10"), _("12"), },
            defaultIndex = 1
        },
        {
            key = "lengthD",
            name = sp .. "\n" .. _("Length") .. " \n\n×10m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        },
        {
            key = "lengthC",
            name = "×100m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 1
        },
        {
            key = "lengthM",
            name = "×1000m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        },
        {
            key = "sign",
            name = sp .. "\n" .. _("Radius") .. "(m)",
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radius",
            name = "",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "dHSign",
            name = sp .. "\n" .. _("ΔHeight") .. "(m)",
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "dHeight",
            name = "",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        },
        {
            key = "dHeightD",
            name = "×10m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        },
        {
            key = "signalSpacingD",
            name = sp .. "\n" .. _("Signal Spacing") .. "\n\n×10m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        
        },
        {
            key = "signalSpacingC",
            name = "×100m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        
        },
        {
            key = "signalSpacingM",
            name = "×1000m",
            values = func.seqMap({0, 9}, tostring),
            defaultIndex = 0
        
        },
        {
            key = "signalPattern",
            name = _("Signal Pattern"),
            values = {_("LRLR"), _("RLRL"), ("LLRR"), _("RRLL"), _("LLLL"), _("RRRR")},
            defaultIndex = 0,
        },
        {
            key = "paraTracks",
            name = sp .. "\n" .. _("Retaining walls"),
            values = {_("None"), _("Both"), _("Inner"), _("Outer")},
            defaultIndex = 0
        },
        {
            key = "paraTracks",
            name = "",
            values = {_("Concrete"), _("Stone brick"), _("Noise barrier")},
            defaultIndex = 0
        }
    }

end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    
    func.forEach(params(), function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end

local updateFn = function(models)
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        
        local nbTracks = params.nbTracks + 1
        local radius = (rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        local length = params.lengthD * 10 + params.lengthC * 100 + params.lengthM * 1000
        local signalSpacing = (function(s) return s == 0 and length or s end)(params.signalSpacingD * 10 + params.signalSpacingC * 100 + params.signalSpacingM * 1000)
        
        local height = (params.dHSign == 0 and 1 or -1) * params.dHeight + params.dHeightD * 10
        local slope = height / length
        
        
        
        local offsets = junction.buildCoors(nbTracks, nbTracks)
        local guideline = arc.byOR(coor.xyz(radius, 0, 0), abs(radius))
        local initRad = radius > 0 and pi or 0
        local dRad = length / radius < 2 * pi and length / radius or 2 * pi * 0.99
        
        local function signalGrouping(result, leftLength)
            return leftLength <= 0 and result / 1 or signalGrouping(result / ((length - leftLength) / length), leftLength - signalSpacing)
        end
        
        local limits = signalGrouping(pipe.new, length)
            * function(r) return func.map2(
                func.range(r, 1, #r - 1),
                func.range(r, 2, #r),
                function(f, t) return
                    {
                        inf = initRad + f * dRad,
                        mid = initRad + (f + t) * 0.5 * dRad,
                        sup = initRad + t * dRad
                    }
                end)
            end
        
        local guidelines = offsets.tracks
            * (radius > 0 and pipe.noop() or pipe.rev())
            * pipe.map(function(o)
                local g = (guideline + o)
                return limits
                    * pipe.map(function(l) return func.with(g:withLimits(l), {offset = o}) end)
            end)
        
        local zsList = signalGrouping(pipe.new, length)
            * function(r) return func.map2(
                func.range(r, 1, #r - 1),
                func.range(r, 2, #r),
                function(f, t) return {
                    {coor.transZ(f * height), coor.transZ((f + t) * 0.5 * height), coor.transZ(slope), coor.transZ(slope)},
                    {coor.transZ((f + t) * 0.5 * height), coor.transZ(t * height), coor.transZ(slope), coor.transZ(slope)}
                }
                end)
            end
        
        local arcs = guidelines
            * pipe.map(pipe.map(junction.generateArc))
            * pipe.map(pipe.map(pipe.range(1, 2)))
            * pipe.map(pipe.map2(zsList, function(a, zs) return func.map2(a, zs, function(ar, nz) return func.map2(ar, nz, coor.apply) end) end))
            * pipe.map(function(segs) return pipe.new
                * func.map2(segs, func.seq(1, #segs), function(e, i) return {
                    edge = pipe.new * e,
                    snap = pipe.new / {i == 1, false} / {false, i == #segs}
                } end)
            end)
            * pipe.map(station.joinEdges)
            * pipe.map(station.mergeEdges)
        
        local signalPattern = {
            func.seqMap({1, nbTracks}, function(i) return i % 2 == 1 end),
            func.seqMap({1, nbTracks}, function(i) return i % 2 ~= 1 end),
            func.seqMap({1, nbTracks}, function(i) return i <= nbTracks * 0.5 end),
            func.seqMap({1, nbTracks}, function(i) return i > nbTracks * 0.5 end),
            func.seqMap({1, nbTracks}, function(_) return true end),
            func.seqMap({1, nbTracks}, function(_) return false end),
        };
        
        local signalOffset = 5 / (signalSpacing < 20 and 20 or signalSpacing)

        return
            {
                edgeLists =
                {
                    pipe.new * {arcs} * station.fusionEdges * pipe.map(station.mergeEdges) * station.prepareEdges * trackBuilder.normal(),
                },
                edgeObjects = pipe.new
                * signalPattern[params.signalPattern + 1]
                * pipe.map2(func.seq(0, nbTracks - 1),
                    function(p, i)
                        return func.seqMap({0, #limits - 1}, function(n)
                            return {
                                edge = (i * #limits + n) * 2 + (p and 1 or 0),
                                param = p and signalOffset or 1 - signalOffset,
                                left = p,
                                model = "railroad/signal_new_block.mdl"
                            }
                        end)
                    end)
                * pipe.flatten(),
                models = {}--(surface.walls + surface.surface) * pipe.flatten(),
            -- terrainAlignmentLists = jM.mergePoly({
            -- equal = jM.projectPolys(coor.transZ(-0.1))(surface.polys.polys),
            -- slot = jM.projectPolys(coor.transZ(-0.1))(surface.polys.trackPolys),
            -- })
            }
    end
end


function data()
    return {
        type = "RAIL_DEPOT",
        description = {
            name = _("Parallel tracks"),
            description = _("A compact tunnel entry")
        },
        availability = {
            yearFrom = 1892
        },
        -- buildMode = "SINGLE",
        -- categories = {"misc"},
        order = 27218,
        -- skipCollision = false,
        -- autoRemovable = false,
        params = params(),
        
        updateFn = updateFn(
            {
                mSidePillar = "flying_junction/concrete/pillar_side.mdl",
                mRoofFenceF = "flying_junction/concrete/roof_fence_front.mdl",
                mRoofFenceS = "flying_junction/concrete/roof_fence_side.mdl",
                mRoof = "flying_junction/concrete/roof.mdl",
                bridgeType = "z_concrete_flying_junction.lua",
            }
    )
    }

end
